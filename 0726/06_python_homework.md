### 1.
sorted()는 메소드의 인자로 전달된 iterable을 정렬하는데 이때 iterable의 원본을 바꾸지 않고 정렬된 결과를 복사한 다른 객체를 리턴한다.
.sort()의 경우 해당 메소드를 호출한 iterable 원본을 수정하여 정렬한다, 그리고 none값을 리턴한다.

실행 결과를 예를 들어 설명하자면
```py
numbers = [3, 1, 5, 2, 4]
a = numbers.sort()
print(a, numbers) # 여기서 값은 None , [1, 2, 3, 4, 5]가 된다.

# 하지만 만약 sort가 아닌 sorted()를 사용할 경우
numbers = [3, 1, 5, 2, 4]
a = sorted(numbers)
print(a, numbers) #여기서 값은 [1, 2, 3, 4, 5], [3, 1, 5, 2, 4]가 된다.
```

### 2.
.append()는 인자로 전달된 값을 그대로 리스트에 추가한다. 하지만 .exten()의 경우 인자로 전달된 iterable을 그대로 추가하는 것이 아니라, 해당 iterable의 내부의 값을 하나하나 리스트에 추가한다.

실행 결과를 예를 들어 설명하자면
```py
a = [1, 2, 3, 4, 5] 

a.append([6,7])
print(a) #여기서 값은 [1, 2, 3, 4, 5, [6, 7]]로 입력받은 리스트가 그대로 추가된다. 

#하지만 만약 .extend()를 사용할 경우
a.extend([6,7])
print(a) #여기서 값은 [1, 2, 3, 4, 5, 6, 7]로 입력받은 리스트의 내부 값이 하나하나 추가된다.
```

### 3.

결과적으로 
```py
a = [1, 2, 5, 4, 5]
b = [1, 2, 5, 4, 5]
```
로 a, b는 같은 값이 나온다.
이는 b를 선언할 때 변수 a의 값을 그대로 할당했기 때문이다. 할당을 할 경우 단순 변수의 값만을 가져오는 것이 아니라 해당 변수에 대한 참조값도 가져오기 때문에 둘 중 하나만을 수정해도 다른 하나도 같이 변하게 된다.
